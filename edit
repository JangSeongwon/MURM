n = random.uniform(0, 0.1)  
n = round(n, 2)  

print in murm.py  
obs_processor check in murm version  

action = np.clip(action[0], a_min=-1, a_max=1)
        
if gripper >= 0:
    gripper = 1
else:
    gripper = -1
#print('gripper',gripper)
        
        IN ROLLOUT FUNCTION
gripper = a[-1]
if gripper >= 0:
    gripper = 1
else:
    gripper = -1
a[-1] = gripper
# print('action', a)        


 # task1
 pos_low=[0.225, -0.55, 1.0],
 pos_high=[0.575, 0.05, 1.2],
 # task2
 # pos_low=[0.25, -0.45, 1.0],
 # pos_high=[0.55, 0.05, 1.25],
 # task3
 # pos_low=[0.25, -0.15, 1.0],
 # pos_high=[0.55, 0.25, 1.25],
 
 
     elif x.size == 153 or x.size == 103 or y.size == 153 or y.size == 103:
        success = []
        if x.size == 153:
            num = 153
        else:
            num = 103
        for i in range(num):
            p = [int(x[i])]
            # print('p', p)
            success = np.append(success, p, axis=0)
        # print(success.size, success)
        success1 = []
        for i in range(num):
            q = [int(y[i])]
            # print('q', q)
            success1 = np.append(success1, q, axis=0)
        # print(success1.size, success1)
        reward = success + success1 - 1


state_env = ClipAction(state_env)


    def render_obs_active(self):
        # eef_pos_for_active_camera = self.get_end_effector_pos()
        eef_pos_for_active_camera = np.array([0.4, -0.5, 1.35])
        # eef_pos_for_active_camera = [float(eef_pos_for_active_camera[0]+0.085),float(eef_pos_for_active_camera[1]),float(eef_pos_for_active_camera[2])]
        # eef_pos_for_active_camera = [float(eef_pos_for_active_camera[0]+0.125),float(eef_pos_for_active_camera[1]),float(eef_pos_for_active_camera[2])]
        # eef_theta_for_active_camera = self.get_end_effector_theta()
        eef_theta_for_active_camera = np.array([0, 30, 0])
        #print(eef_pos_for_active_camera)
        #print('Total',eef_theta_for_active_camera)
        # print('x',eef_theta_for_active_camera[0])
        # print('y',eef_theta_for_active_camera[1])
        # print('z',eef_theta_for_active_camera[2])

        view_matrix_obs_active = bullet.get_view_matrix(
            target_pos=eef_pos_for_active_camera, distance=0.25,
            yaw=eef_theta_for_active_camera[0], pitch=eef_theta_for_active_camera[1]-90, roll=eef_theta_for_active_camera[2]-270, up_axis_index=2)
        projection_matrix_obs_active = bullet.get_projection_matrix(
            self.obs_img_dim_active, self.obs_img_dim_active)
        # img_tuple2 = p.getCameraImage(width=self.obs_img_dim_active,
        #                  height=self.obs_img_dim_active,
        #                  viewMatrix=view_matrix_obs_active,
        #                  projectionMatrix=projection_matrix_obs_active,
        #                  shadow=1,
        #                  lightDirection=[1,1,1],
        #                  renderer=p.ER_TINY_RENDERER)
        # _, _, img2, depth2, segmentation2 = img_tuple2
        #
        # img_active = img2[:, :, :-1]
        img_active, depth, segmentation = bullet.render(
            self.obs_img_dim_active, self.obs_img_dim_active, view_matrix_obs_active,
            projection_matrix_obs_active, lightdistance=0.1, shadow=0, light_direction=[1, 1, 1], gaussian_width=5)
        if self._transpose_image:
            img_active = np.transpose(img_active, (2, 0, 1))
        return img_active









